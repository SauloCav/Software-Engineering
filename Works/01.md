# Quest 18: 
### Introduction
“No Silver Bullet — Essence and Accident in Software Engineering” is a widely discussed paper on software engineering written by Turing Award winner Fred Brooks in 1987. This is a summary of the key ideas.

Software engineering has its limits. No piece of software that has been build in the past is error-free or completely reliable. There is a need in the software engineering field for software development methods which would produce simple and reliable software.

uch of the progress in software engineering productivity that past generations experienced can be attributed to removing the accidental complexity that arose over time. By making hardware more efficient and accessible, and programming languages more approachable, we solved the easy problems and created an environment for more efficient development.

We’re now at a point where the low-hanging fruit has been picked, and if we want to continue building software better and faster, we need to figure out how to solve the challenges that are inherent in software development. This paper outlines how we might approach that.

### Paper Summary
The crux of the paper is that there’s no silver bullet; no one solution that is going to make software development easier, better and cheaper, all in one quick swoop.

“Skepticism is not pessimism. Although we see no startling breakthroughs, and indeed, believe such to be inconsistent with the nature of software, many encouraging innovations are underway. A disciplined, consistent effort to develop, propagate, and exploit them should indeed yield an order-of-magnitude improvement. There is no royal road, but there is a road.”

Software gets better not through magical solutions, but with great effort. Care and discipline towards the cleanliness of our code is essential to building better software. Building software to solve a problem isn’t difficult, identifying and understanding the problem is the difficult part. You cannot engineer well if you don’t understand the problem you’re solving. As Brooks says:

“I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the lab or of representing it and testing the fidelity of the representation. We still make syntax errors, to be sure; but they are fuzz compared to the conceptual errors in most systems.”

Software becomes an awful lot harder when it needs to be scaled because scaling isn’t a linear process. Scaling introduces exponential complexity because of the increasing number of interactions between elements. A scaling-up of software is not merely a repetition of the same elements in a larger size; it is necessarily an increase in the number of different elements. In most cases, the elements interact with each other in some nonlinear fashion, and the complexity of the whole increases much more than linearly.

This is pertinent to any organisation attempting to scale its engineering offerings and capabilities. There is an awful lot of complexity that comes into play as teams and products interact with one another. As they get bigger this gets increasingly complex.

Complexity is inevitable, and your rate of success is directly proportional to your ability to deal with it.

### Essential difficulties
Software is currently not being developed with a mindset of tackling software engineering issues like “conformity, changeability, flexibility, invisibility and complexity”,(Brooks, 1995).

In the past, software has depended on hardware to run smoothly without malfunctioning but nowadays hardware technology is advancing rapidly by the day and becoming cheaper by the minute. However it is the opposite for software engineering, it is becoming more difficult to keep up with the advancement of hardware technology to the extent that software engineers do not bother to build software that can match up the capabilities of the current hardware capabilities.

### Complexity
The software engineering field in itself is growing, young minds are coming up with more complex programming languages to solve real life issues where applicable. Each programming language has its own specific purpose in a piece of software resulting in more complicated functions. This means a single software project can have more than five different programming languages performing different tasks which further contribute to the complexity of the functions and the software itself.

Although complex software tend to perform complex tasks, this however makes it difficult for the software to be integrated into another piece of software or advanced in some way without having to re-write majority of software functions which would in-turn cause more errors, increase costs of software maintenance that need to be dealt with in the future.

### Conformity
Every software piece ever written has to run somewhere, it has to fit-in somewhere where there have been other software systems running long before the new software was built. Software often has to be interfaced with older systems built before the current software, this makes it rather difficult for software to perform they way it was built to perform because sometimes it does not fit-in with older systems.

### Changeability
As to everything in the world, software also has a lifetime. There comes a point in a software's life-cycle where the functions and capabilities of a software need to change or improve. People are becoming wiser as the years go by, meaning people would start recognising the incapabilities of everything out there including software since our jobs and lives merely depend on it. This means a piece of software or software functions are dependent on the technological advancement of its surroundings.

### Invisibility
Unlike any other object, software can not be viewed from a bird's eye view like any object drawn in a 3D CAD(Computer Aided Diagram) system. This inability contributes to the limitations of software engineering. Software engineers tend to just build a piece of software without having a clear idea of how the final product would look or perform since there is no way to visualise it before development, which is why there is a need for a prototype to lay out the major functions of the software that seem impossible to complete.

### Solved accidental difficulties
#### High-level languages
High-level programming languages have made it easier for people to learn programming and write the famous “Hello World!” without much struggle. High-level languages are more concerned with what a user sees on the front-end of a software and how each function accomplishes a certain task rather than focusing on which register stores a particular process running in a software as lower-level languages do. High-level languages are close to plain English, this factor has contributed to the rapid growth of programmers around the world, therefore solving some of the issues in the software engineering field.

#### Time – sharing
As more people learn how to program, they start sharing insights and start to use a variety of communication medium to put their work out there for anyone to access and get solutions for problems they have been experiencing in the past.

### Hopes for the silver
#### Ada language
(Brooks, 1995) argues that Ada programming language and high-level languages are promising to tackle some of the issues experienced in software engineering, Ada was specifically designed for system functions where overall system efficiency and reliability is vital.

#### Object - oriented programming (OOP)
Object – oriented programming is one of the advancements in programming that has made it easier for programmers to define variables or objects in this matter. Each object would be defined on the basis of what data structures would be stored in it to serve a purpose in the program or software. Examples of widely used object – oriented programming languages would be C++ and Java.

#### Artificial Intelligence (AI)
(Brooks, 1995) argues that Artificial Intelligence is not what people are expecting it to be, it is merely just computer hardware and software processes which choose the best solution in a given problem likely to be chosen by humans.

### Expert Systems
Every software system should be designed and built in such a manner that it would be able to test and diagnose itself when it malfunctions, However this would not be an easy task to implement. Building an expert system would require very knowledgeable programmers which could build a general system to solve multiple complex tasks.

#### Automatic programming
It is essential to have software systems that are able to program themselves, and write program solutions of problem from a problem statement automatically.

#### Graphical programming
According to (Brooks, 1995)⁠, presentation of software functions in a graphical manner does not contribute to the simplicity of having an overview of a system since diagrams like flow charts tend to be bigger than a normal screen size of a computer. Furthermore, software functions are often more complex than they seem on a flow chart.

#### Program verification
Program verification is where most programmers spend time and it is one of the most important steps in a software life-cycle. Verifying a program before the testing phase can eliminate a lot of anomalies, it could even reduce the time spent on testing the actual software because each requirement would be verified before being implemented.

#### Environments and tools
Given the amount of tools available in this modern day to write software, there is no excuse as to why software engineers keep producing unreliable and unmaintainable software. Each programmer can program on any environment they feel comfortable, there are no limitations.

### Promising attacks on conceptual essence
As the large number of software engineers increases daily, there is more competition, more software available for anyone to utilise freely, this benefit means that whatever software one is trying to build may already be out there somewhere.

People are always trying to get things done as quick as possible, even though software engineers are to write their own software, more often it makes sense to purchase what is available out there rather than building something that has already been built.

Part of every software development model is defining the requirements, this part of a software life-cycle outlines all the necessary functions or task which the software should complete, this is where the complexity of a software project is weighed. Among software engineers, it is a known fact that “customers never know what they want”.

### How did software get better and faster in the past?
By attacking the accidental complexity. We picked the low-hanging fruit and made huge progress through the following:

#### High-level languages
The most powerful stroke for software productivity, reliability, and simplicity has been the progressive use of high-level languages for programming. Most observers credit that development with at least a factor of five in productivity, and with concomitant gains in reliability, simplicity, and comprehensibility.
#### Time-sharing
(note that the paper was written in 1987 when development resources typically had to be shared). Most observers credit time-sharing with a major improvement in the productivity of programmers and in the quality of their product, although not so large as that brought by high-level languages. Time-sharing preserves immediacy and enables us to maintain an overview of complexity. The slow turnaround of batch programming means that we inevitably forget the minutiae, if not the very thrust, of what we were thinking when we stopped programming and called for compilation and execution.
#### Unified programming environments
Unix and Interlisp, the first integrated programming environments to come into widespread use, are perceived to have improved productivity by integral factors. Why? They attack the accidental difficulties of using programs together, by providing integrated libraries, unified file formats, and piles and filters. As a result, conceptual structures that in principle could always call, feed, and use one another can indeed easily do so in practice.

### How do we make software better today?
The low-hanging fruit has been picked, what do we attack next? Brooks provides some suggestions, many of which are still relevant 34 years later.

#### Buy, don’t build.
The most radical possible solution for constructing software is not to construct it at all. Every day this becomes easier, as more and more vendors offer more and better software products for a dizzying variety of applications.

Brooks believes that the development of the mass market for software is the most profound long-run trend in software engineering. The cost of software has always been development cost, not replication cost. Sharing that cost among even a few users radically cuts the per-user cost. Another way of looking at it is that the use of n copies of a software system effectively multiplies the productivity of its developers by n.

Brooks had elsewhere proposed a marketplace for individual modules. Any such product is cheaper to buy than to build afresh. Even at a cost of $100,000, a purchased piece of software is costing only about as much as one programmer-year. And delivery is immediate, at least for products that really exist, products whose developer can refer the prospect to a happy user. Such products tend to be much better documented and somewhat better maintained than homegrown software.

You can think of this from the perspective of the buyer or the builder. Most times, it’ll make sense to buy the software. Every now and then, you’ll realise that you’re in the perfect position to build something that doesn’t exist yet, or exists, but isn’t very good. This is a chance to capitalise because if you build it well, there will be buyers.

#### Equip people with technology.
“I believe the single most powerful software productivity strategy for many organisations today is to equip the computer-naïve intellectual workers on the firing line with personal computers and good generalised writing, drawing, file and spreadsheet programs, and turn them loose. The same strategy, with simple programming capabilities, will also work for hundreds of laboratory scientists.”

While the programs might have changed, the essence of what we’re doing when we build software for people hasn’t. Building and delivering software is about giving smart people tools to make ultra-smart decisions. Equip people doing good work to go out and do great work. That’s the beauty of software, it’s an easily replicable force multiplier for people’s efforts, and it provides more leverage than almost anything else.

#### Get better at understanding what to build.
The hardest part of building software is deciding what to build.

Establishing the detailed technical requirements, including all the interfaces to people, to machines, and to other software systems, is difficult. No other part of the work so cripples the resulting system if done wrong. No other part is more difficult to rectify later.

The best developers are able to identify and understand the problem to an extent that they can build useful and delightful solutions for customers. This is why it’s so important for developers to not just be focused on the nitty-gritty implementation details, but to be product-minded about the solutions they build.


# Quest 19: 

O uso do homem-mês como unidade de esforço usada para estimativas e cronogramas é sem dúvidas a maior e mais perigosa falácia da engenharia de software. Isso implica que homens e meses são intercambiáveis, o que não é verdade no mundo da programação. Essa lógica é válida apenas em contextos que são completamente divisíveis e não dependentes, como por exemplo, debulhar 1 tonelada de milho.

Quando uma tarefa não pode ser dividida por limitações sequenciais, como é o caso do software, a adição de mais força de trabalho não implica na redução do tempo de entrega daquela tarefa.

"Uma mulher grávida leva nove meses para parir um filho, porém nove mulheres não parem um filho em um mês."

Isso deveria ser básico para qualquer pessoa que gerencia uma equipe envolvida com software. Mas infelizmente não é.

O livro detalha como adicionar pessoas a um projeto atrasado é a causa dos atrasos subsequentes. Quantas pessoas o gestor deve alocar para uma atividade, a fim de otimizar o seu tempo de entrega, é definitivamente uma das atividades mais difíceis da engenharia de software. Com poucos homens, irá demorar mais, porém com muitos homens pode demorar ainda mais. Encontrar esse meio termo é o nosso desafio.

Brooks questiona: Como um projeto pode atrasar um ano? Resposta mais clara é impossível: Atrasando um dia de cada vez.

A maioria dos programadores são otimistas, porém a premissa de que “tudo irá bem” e que “cada tarefa tomará apenas o tempo que deve tomar” é completamente falsa. Na programação, tudo é interdependente. Se der algo errado numa tarefa, a tarefa seguinte, que depende da primeira, também irá sair do planejado. E assim o projeto vai atrasando dia após dia, de maneira cumulativa.



IF YOU'VE EVER WORKED ON A SOFTWARE DEVELOPMENT PROJECT UNDER A TIME CRUNCH, THEN YOU MAY HAVE HEARD THE PHRASE "MYTHICAL MAN MONTH."
This phrase will often get uttered by a well-read team member when presented with a business stakeholder who wants to throw more bodies at the project to make it go faster. As often as the concept comes up, it never really lives beyond my under-the-breath mutterings. I tend not to share it with clients. Because how do you explain the “mythical man month” to Mr. CEO In A Hurry?

Well for starters, it’s helpful to read the essay. Frederick P. Brooks warns us that in software, man hours and months are not interchangeable. You can’t add more men in order to make a project go faster. CEOs and businessey types are prone to thinking this way because it’s true in most other production settings (e.g. manufacturing or farming).

Adding more labor to go faster doesn't work in software for two reasons:

1. Programming tasks are not partitionable.
“Men and months are interchangeable commodities only when a task can be partitioned among many workers with no communication among them.” Here’s a picture for graphy types:

If the tasks can’t be partitioned, they have sequential constraints. This means that increasing the team won’t bring any speed gains.

i.e. No matter how many women you add to a baby-making team, it will still take 9 months to produce that baby!

2. Programming requires communication.

There are two types of communication: training-related and task-related. The real drain is task-related intercommunication, which increases level of effort by n(n-1)/2 with each new team member.
So team-of-3 requires three times the intercommunication of team-of-2.
And team-of-4 requires six times the intercommunication of team-of-2.

Any gains in task completion are saddled with huge increases in project communication overhead. And so you are no better off deadline-wise.

Wonder if I ought to carry these graphs around — ready to whip out during any client meeting. Or maybe I should practice drawing them on the whiteboard.

It’s hard to believe this book was written in 1975. So much of what Brooks describes are concepts and practices that didn't even have a name yet.

Some passages read like software engineering history (sharing machine time and employing documentation secretaries?). And others like The Mythical Man Month read as if they were written yesterday.

Well... except for the “Man” part.



- More software projects have gone awry for lack of calendar time than for all other causes combined.
- Why? a) Estimation techniques are under-developed, especially in assuming all will go well. b) People and time are not interchangeable. c) Software managers are not stubborn in pushing back against management. d) Schedule progress is poorly monitored, and techniques proven in other fields are not adopted in software. e) When a project is delayed, more people are added, which is like dousing a fire with petrol.
- Let’s look at these one by one. We tend to be optimistic about our ideas, but their incompleteness and inconsistencies becomes clear only during implementation.
- More the tasks in a project, more the chance that one will slip, delaying the entire project. Big projects are guaranteed to be late.
- Doubling head count halves time only if there’s no overhead. This overhead comes in two varieties: a) Training in technology, goals, and how the team is being run. This can’t be partitioned; it increases linearly with headcount b) Communication, which is quadratic, or worse considering multi-person meetings.
- Because of all this, adding people causes the schedule to shorten at a lower rate than the ideal 1/N, and actually lengthen beyond a point.
- To schedule a software task, allocate time to a) Planning b) Coding c) Debugging
- The parts of a task that are easy to estimate end up taking less time.
- Cutting testing time because of schedule pressure results in unplanned delays instead of planned delays. This is worse.
- If an omelette is promised in two minutes but doesn’t arrive, turning up the heat will produce an omelette half burned and half raw.
- Making unreasonable schedules to meet management’s desired date is more common in software than other engineering fields because we have no hard data, only hunches.
- Software engineers should share more data about productivity, bug frequency, estimating rules, and so on.
- Managers should stiffen their backbones and defend their hunches, since they’re better than wishful thinking on the part of management.
- When a project is delayed, trim the task and try to stick to the timeline.
- Adding manpower to a late project makes it later.
- You can take a given schedule and lengthen it by reducing manpower, but not the other way around.



# Quest 18 resumida: 
### Introdução
“No Silver Bullet — Essence and Accident in Software Engineering” é um artigo amplamente discutido sobre engenharia de software escrito pelo vencedor do Turing Award, Fred Brooks, em 1987. Este é um resumo das principais ideias.

A engenharia de software tem seus limites. Nenhum software desenvolvido no passado está livre de erros ou totalmente confiável. Há uma necessidade no campo da engenharia de software por métodos de desenvolvimento de software que produzam software simples e confiável.

Muito do progresso na produtividade da engenharia de software que as gerações passadas experimentaram pode ser atribuído à remoção da complexidade acidental que surgiu ao longo do tempo. Ao tornar o hardware mais eficiente e acessível e as linguagens de programação mais acessíveis, resolvemos os problemas fáceis e criamos um ambiente para um desenvolvimento mais eficiente.

Agora estamos em um ponto em que a fruta mais fácil foi colhida e, se quisermos continuar construindo software melhor e mais rápido, precisamos descobrir como resolver os desafios inerentes ao desenvolvimento de software. Este artigo descreve como podemos abordar isso.

### Resumo do Artigo
O cerne do papel é que não há bala de prata; nenhuma solução que tornará o desenvolvimento de software mais fácil, melhor e mais barato, tudo de uma só vez.

“Ceticismo não é pessimismo. Embora não vejamos avanços surpreendentes e, de fato, acreditemos que sejam inconsistentes com a natureza do software, muitas inovações encorajadoras estão em andamento. Um esforço disciplinado e consistente para desenvolvê-los, propagá-los e explorá-los deve, de fato, produzir uma melhoria de ordem de magnitude. Não há estrada real, mas há uma estrada.”

O software melhora não por meio de soluções mágicas, mas com grande esforço. O cuidado e a disciplina com a limpeza do nosso código são essenciais para a construção de um software melhor. Construir software para resolver um problema não é difícil, identificar e entender o problema é a parte difícil. Você não pode projetar bem se não entender o problema que está resolvendo. Como diz Brooks:

“Acredito que a parte difícil da construção de software seja a especificação, o design e o teste dessa construção conceitual, não o laboratório ou a representação e o teste da fidelidade da representação. Ainda cometemos erros de sintaxe, com certeza; mas eles são confusos em comparação com os erros conceituais na maioria dos sistemas.”

O software se torna muito mais difícil quando precisa ser dimensionado porque o dimensionamento não é um processo linear. O escalonamento introduz complexidade exponencial devido ao número crescente de interações entre os elementos. Uma expansão de software não é meramente uma repetição dos mesmos elementos em um tamanho maior; é necessariamente um aumento no número de elementos diferentes. Na maioria dos casos, os elementos interagem uns com os outros de alguma forma não linear, e a complexidade do todo aumenta muito mais do que linearmente.

Isso é pertinente para qualquer organização que esteja tentando escalar suas ofertas e recursos de engenharia. Há uma enorme complexidade que entra em jogo quando as equipes e os produtos interagem uns com os outros. À medida que crescem, isso fica cada vez mais complexo.

A complexidade é inevitável e sua taxa de sucesso é diretamente proporcional à sua capacidade de lidar com ela.

### Dificuldades essenciais
Atualmente, o software não está sendo desenvolvido com uma mentalidade de abordar questões de engenharia de software como “conformidade, mutabilidade, flexibilidade, invisibilidade e complexidade” (Brooks, 1995).

No passado, o software dependia do hardware para funcionar sem problemas, mas hoje em dia a tecnologia de hardware está avançando rapidamente a cada dia e se tornando mais barata a cada minuto. No entanto, é o oposto para a engenharia de software, está se tornando mais difícil acompanhar o avanço da tecnologia de hardware na medida em que os engenheiros de software não se preocupam em criar software que corresponda aos recursos de hardware atuais.

### Complexidade
O campo de engenharia de software em si está crescendo, mentes jovens estão criando linguagens de programação mais complexas para resolver problemas da vida real, quando aplicável. Cada linguagem de programação tem seu próprio propósito específico em um software, resultando em funções mais complicadas. Isso significa que um único projeto de software pode ter mais de cinco linguagens de programação diferentes executando tarefas diferentes, o que contribui ainda mais para a complexidade das funções e do próprio software.

Embora o software complexo tenda a executar tarefas complexas, isso torna difícil para o software ser integrado a outro software ou avançado de alguma forma sem ter que reescrever a maioria das funções do software, o que, por sua vez, causaria mais erros, aumentaria custos de manutenção de software que precisam ser tratados no futuro.

### Conformidade
Cada pedaço de software já escrito tem que rodar em algum lugar, tem que se encaixar em algum lugar onde havia outros sistemas de software rodando muito antes do novo software ser construído. O software muitas vezes tem que ser conectado com sistemas mais antigos construídos antes do software atual, isso torna bastante difícil para o software executar da maneira que foi construído para funcionar porque às vezes não se encaixa em sistemas mais antigos.

### Modificabilidade
Como tudo no mundo, o software também tem um tempo de vida. Chega um ponto no ciclo de vida de um software em que as funções e capacidades de um software precisam mudar ou melhorar. As pessoas estão se tornando mais sábias com o passar dos anos, o que significa que as pessoas começariam a reconhecer as incapacidades de tudo, incluindo software, já que nossos empregos e vidas dependem apenas disso. Isso significa que um software ou funções de software dependem do avanço tecnológico de seu entorno.

### Invisibilidade
Ao contrário de qualquer outro objeto, o software não pode ser visto do ponto de vista de um pássaro como qualquer objeto desenhado em um sistema CAD 3D (diagrama assistido por computador). Essa incapacidade contribui para as limitações da engenharia de software. Os engenheiros de software tendem a apenas construir um pedaço de software sem ter uma ideia clara de como o produto final ficaria ou se comportaria, já que não há como visualizá-lo antes do desenvolvimento, e é por isso que existe a necessidade de um protótipo para definir os principais funções do software que parecem impossíveis de completar.

### Dificuldades acidentais resolvidas
#### Linguagens de alto nível
As linguagens de programação de alto nível tornaram mais fácil para as pessoas aprender a programar e escrever o famoso “Hello World!” sem muita luta. As linguagens de alto nível estão mais preocupadas com o que um usuário vê no front-end de um software e como cada função realiza uma determinada tarefa, em vez de focar em qual registrador armazena um determinado processo em execução em um software, como fazem as linguagens de nível inferior. As linguagens de alto nível estão próximas do inglês simples, esse fator contribuiu para o rápido crescimento de programadores em todo o mundo, resolvendo assim alguns dos problemas no campo da engenharia de software.

#### Compartilhamento de tempo
À medida que mais pessoas aprendem a programar, elas começam a compartilhar ideias e a usar uma variedade de meios de comunicação para divulgar seu trabalho para que todos possam acessar e obter soluções para problemas que enfrentaram no passado.

### Esperança pela prata
#### Linguagem Ada
(Brooks, 1995) argumenta que a linguagem de programação Ada e as linguagens de alto nível são promissoras para resolver alguns dos problemas enfrentados na engenharia de software, Ada foi projetada especificamente para funções do sistema em que a eficiência e a confiabilidade geral do sistema são vitais.

#### Programação orientada a objetos (OOP)
A programação orientada a objetos é um dos avanços na programação que tornou mais fácil para os programadores definir variáveis ou objetos nesse assunto. Cada objeto seria definido com base em quais estruturas de dados seriam armazenadas nele para servir a um propósito no programa ou software. Exemplos de linguagens de programação orientadas a objetos amplamente usadas seriam C++ e Java.

#### Inteligência Artificial (IA)
(Brooks, 1995) argumenta que a Inteligência Artificial não é o que as pessoas esperam que seja, é meramente apenas processos de hardware e software de computador que escolhem a melhor solução para um determinado problema que provavelmente será escolhido por humanos.

### Sistemas especializados
Todo sistema de software deve ser projetado e construído de forma que seja capaz de testar e diagnosticar a si mesmo quando apresentar problemas de funcionamento. No entanto, essa não seria uma tarefa fácil de implementar. A construção de um sistema especialista exigiria programadores muito experientes que pudessem construir um sistema geral para resolver várias tarefas complexas.

#### Programação automática
É essencial ter sistemas de software que sejam capazes de se programar e escrever soluções de programa de problemas automaticamente a partir de uma declaração de problema.

#### Programação gráfica
Segundo (Brooks, 1995)⁠, a apresentação das funções do software de forma gráfica não contribui para a simplicidade de se ter uma visão geral de um sistema, pois diagramas como fluxogramas tendem a ser maiores do que o tamanho normal da tela de um computador. Além disso, as funções do software costumam ser mais complexas do que parecem em um fluxograma.

#### Verificação do programa
A verificação do programa é onde a maioria dos programadores gasta tempo e é uma das etapas mais importantes no ciclo de vida de um software. Verificar um programa antes da fase de teste pode eliminar muitas anomalias, pode até reduzir o tempo gasto no teste do software real porque cada requisito seria verificado antes de ser implementado.

#### Ambientes e ferramentas
Dada a quantidade de ferramentas disponíveis nos dias de hoje para escrever software, não há desculpa para o motivo pelo qual os engenheiros de software continuam produzindo software não confiável e sem manutenção. Cada programador pode programar em qualquer ambiente que se sinta confortável, não há limitações.

### Ataques promissores à essência conceitual
Como o grande número de engenheiros de software aumenta diariamente, há mais concorrência, mais software disponível para qualquer um utilizar livremente, esse benefício significa que qualquer software que alguém esteja tentando construir já pode estar disponível em algum lugar.

As pessoas estão sempre tentando fazer as coisas o mais rápido possível, mesmo que os engenheiros de software escrevam seu próprio software, na maioria das vezes faz sentido comprar o que está disponível, em vez de construir algo que já foi construído.

Parte de todo modelo de desenvolvimento de software é definir os requisitos, essa parte do ciclo de vida de um software descreve todas as funções ou tarefas necessárias que o software deve concluir. É aqui que a complexidade de um projeto de software é pesada. Entre os engenheiros de software, é um fato conhecido que “os clientes nunca sabem o que querem”.

### Como o software ficou melhor e mais rápido no passado?
Atacando a complexidade acidental. Nós colhemos as frutas mais fáceis e fizemos um grande progresso através do seguinte:

#### Linguagens de alto nível
O golpe mais poderoso para produtividade, confiabilidade e simplicidade de software tem sido o uso progressivo de linguagens de alto nível para programação. A maioria dos observadores atribui a esse desenvolvimento pelo menos um fator de cinco em produtividade e com ganhos concomitantes em confiabilidade, simplicidade e compreensão.
#### Compartilhamento de tempo
(observe que o documento foi escrito em 1987, quando os recursos de desenvolvimento geralmente precisavam ser compartilhados). A maioria dos observadores credita ao compartilhamento de tempo uma grande melhoria na produtividade dos programadores e na qualidade de seu produto, embora não tão grande quanto a trazida pelas linguagens de alto nível. O compartilhamento de tempo preserva o imediatismo e nos permite manter uma visão geral da complexidade. A lenta reviravolta da programação em lote significa que inevitavelmente esquecemos as minúcias, se não a essência, do que estávamos pensando quando paramos de programar e pedimos compilação e execução.
#### Ambientes de programação unificados
Unix e Interlisp, os primeiros ambientes de programação integrados a serem amplamente utilizados, são percebidos como tendo melhorado a produtividade por fatores integrais. Por que? Eles atacam as dificuldades acidentais de usar programas juntos, fornecendo bibliotecas integradas, formatos de arquivo unificados e pilhas e filtros. Como resultado, estruturas conceituais que, em princípio, sempre poderiam chamar, alimentar e usar umas às outras podem, de fato, fazê-lo facilmente na prática.

### Como tornamos o software melhor hoje?
A fruta mais baixa foi colhida, o que atacamos a seguir? Brooks fornece algumas sugestões, muitas das quais ainda são relevantes 34 anos depois.

#### Compre, não construa.
A solução mais radical possível para a construção de software é não construí-lo. A cada dia isso se torna mais fácil, à medida que mais e mais fornecedores oferecem mais e melhores produtos de software para uma variedade estonteante de aplicativos.

Brooks acredita que o desenvolvimento do mercado de massa para software é a mais profunda tendência de longo prazo na engenharia de software. O custo do software sempre foi o custo de desenvolvimento, não o custo de replicação. Compartilhar esse custo entre até mesmo alguns usuários reduz radicalmente o custo por usuário. Outra maneira de ver isso é que o uso de n cópias de um sistema de software efetivamente multiplica a produtividade de seus desenvolvedores por n.

Brooks havia proposto em outro lugar um mercado para módulos individuais. Qualquer produto desse tipo é mais barato de comprar do que construir de novo. Mesmo a um custo de $ 100.000, um pedaço de software comprado está custando apenas tanto quanto um programador-ano. E a entrega é imediata, pelo menos para produtos que realmente existem, produtos cujo desenvolvedor pode encaminhar o prospect para um usuário satisfeito. Esses produtos tendem a ser muito mais bem documentados e um pouco mais bem mantidos do que o software doméstico.

Você pode pensar nisso da perspectiva do comprador ou do construtor. Na maioria das vezes, fará sentido comprar o software. De vez em quando, você vai perceber que está na posição perfeita para construir algo que ainda não existe, ou existe, mas não é muito bom. Esta é uma chance de capitalizar porque se você construir bem, haverá compradores.

#### Equipar as pessoas com tecnologia.
“Acredito que a estratégia de produtividade de software mais poderosa para muitas organizações hoje é equipar os trabalhadores intelectuais ingênuos de computadores na linha de fogo com computadores pessoais e bons programas generalizados de redação, desenho, arquivo e planilha, e liberá-los. A mesma estratégia, com recursos de programação simples, também funcionará para centenas de cientistas de laboratório”.

Embora os programas possam ter mudado, a essência do que estamos fazendo quando criamos software para as pessoas não mudou. Construir e entregar software é dar ferramentas para pessoas inteligentes tomarem decisões ultra-inteligentes. Equipe as pessoas que fazem um bom trabalho para sair e fazer um ótimo trabalho. Essa é a beleza do software, é um multiplicador de força facilmente replicável para os esforços das pessoas e fornece mais alavancagem do que quase qualquer outra coisa.

#### Entenda melhor o que construir.
A parte mais difícil da construção de software é decidir o que construir.

Estabelecer os requisitos técnicos detalhados, incluindo todas as interfaces para pessoas, máquinas e outros sistemas de software, é difícil. Nenhuma outra parte do trabalho prejudica tanto o sistema resultante se for feita de maneira errada. Nenhuma outra parte é mais difícil de corrigir depois.

Os melhores desenvolvedores são capazes de identificar e entender o problema de forma que possam construir soluções úteis e agradáveis para os clientes. É por isso que é tão importante que os desenvolvedores não se concentrem apenas nos detalhes básicos da implementação, mas tenham uma mentalidade de produto sobre as soluções que criam.


# Quest 19 resumida: 
Em software, horas-homem e meses não são intercambiáveis. Você não pode adicionar mais homens para fazer um projeto ir mais rápido. CEOs e tipos de negócios tendem a pensar dessa maneira porque é verdade na maioria dos outros ambientes de produção (por exemplo, manufatura ou agricultura).

Brooks questiona: "Como um projeto pode atrasar um ano? Atrasando um dia de cada vez!"

A maioria dos programadores são otimistas, porém a premissa de que “tudo irá bem” e que “cada tarefa tomará apenas o tempo que deve tomar” é completamente falsa. Na programação, tudo é interdependente. Se der algo errado numa tarefa, a tarefa seguinte, que depende da primeira, também irá sair do planejado. E assim o projeto vai atrasando dia após dia, de maneira cumulativa. Mais projetos de software deram errado por falta de tempo no calendário do que por todas as outras causas combinadas.

Adicionar mais trabalho para ir mais rápido não funciona no software pelos seguintes motivos:

### 1. As tarefas de programação não são particionáveis.
Homens e meses são mercadorias intercambiáveis apenas quando uma tarefa pode ser dividida entre muitos trabalhadores sem comunicação entre eles.
Se as tarefas não puderem ser particionadas, elas terão restrições sequenciais. Isso significa que aumentar a equipe não trará nenhum ganho de velocidade.
Quando uma tarefa não pode ser dividida por limitações sequenciais, como é o caso do software, a adição de mais força de trabalho não implica na redução do tempo de entrega daquela tarefa.
"Uma mulher grávida leva nove meses para parir um filho, porém nove mulheres não parem um filho em um mês."

### 2. As técnicas de estimativa estão subdesenvolvidas, especialmente ao assumir que tudo correrá bem.
Fazer cronogramas irracionais para atender a data desejada pela administração é mais comum em software do que em outras áreas de engenharia porque não temos dados concretos, apenas palpites. E o pior tipo de palpite possível é o otimista.

### 3. O andamento do cronograma é mal monitorado e técnicas comprovadas em outras áreas não são adotadas no software.
Os engenheiros de software devem compartilhar mais dados sobre produtividade, frequência de bugs, regras de estimativa e assim por diante. Além disso, de nada adianta usar métricas de produtividade de outras áreas como indústrias na produção de software.

### 4. Quando um projeto é adiado, mais pessoas são adicionadas
Você pode pegar um determinado horário e alongá-lo reduzindo a mão de obra, mas não o contrário. Quando um projeto está atrasado, reduza a tarefa e tente seguir o cronograma. Adicionar mão-de-obra a um projeto atrasado torna-o mais atrasado.

### 5. Programação requer comunicação.
Existem dois tipos de comunicação: relacionada ao treinamento e relacionada à tarefa. O verdadeiro dreno é a intercomunicação relacionada à tarefa, que aumenta o nível de esforço em n(n-1)/2 com cada novo membro da equipe.
Portanto, o time de 3 requer três vezes a intercomunicação do time de 2. E o time de 4 requer seis vezes a intercomunicação do time de 2.
Quaisquer ganhos na conclusão da tarefa são sobrecarregados com grandes aumentos na sobrecarga de comunicação do projeto. E, portanto, você não está melhor em termos de prazo.

