# Trab 01

## Quest 01: 


## Quest 02: 


## Quest 03: 


## Quest 04: 


## Quest 05: 


## Quest 06: 


## Quest 07: 


## Quest 08: 


## Quest 09: 


## Quest 10: 


## Quest 11: 


## Quest 12: 


## Quest 13: 


## Quest 14: 


## Quest 15: 


## Quest 16: 


## Quest 17: 


## Quest 18: 
### Introduction
“No Silver Bullet — Essence and Accident in Software Engineering” is a widely discussed paper on software engineering written by Turing Award winner Fred Brooks in 1987. This is a summary of the key ideas.

Software engineering has its limits. No piece of software that has been build in the past is error-free or completely reliable. There is a need in the software engineering field for software development methods which would produce simple and reliable software.

uch of the progress in software engineering productivity that past generations experienced can be attributed to removing the accidental complexity that arose over time. By making hardware more efficient and accessible, and programming languages more approachable, we solved the easy problems and created an environment for more efficient development.

We’re now at a point where the low-hanging fruit has been picked, and if we want to continue building software better and faster, we need to figure out how to solve the challenges that are inherent in software development. This paper outlines how we might approach that.

### Paper Summary
The crux of the paper is that there’s no silver bullet; no one solution that is going to make software development easier, better and cheaper, all in one quick swoop.

“Skepticism is not pessimism. Although we see no startling breakthroughs, and indeed, believe such to be inconsistent with the nature of software, many encouraging innovations are underway. A disciplined, consistent effort to develop, propagate, and exploit them should indeed yield an order-of-magnitude improvement. There is no royal road, but there is a road.”

Software gets better not through magical solutions, but with great effort. Care and discipline towards the cleanliness of our code is essential to building better software. Building software to solve a problem isn’t difficult, identifying and understanding the problem is the difficult part. You cannot engineer well if you don’t understand the problem you’re solving. As Brooks says:

“I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the lab or of representing it and testing the fidelity of the representation. We still make syntax errors, to be sure; but they are fuzz compared to the conceptual errors in most systems.”

Software becomes an awful lot harder when it needs to be scaled because scaling isn’t a linear process. Scaling introduces exponential complexity because of the increasing number of interactions between elements. A scaling-up of software is not merely a repetition of the same elements in a larger size; it is necessarily an increase in the number of different elements. In most cases, the elements interact with each other in some nonlinear fashion, and the complexity of the whole increases much more than linearly.

This is pertinent to any organisation attempting to scale its engineering offerings and capabilities. There is an awful lot of complexity that comes into play as teams and products interact with one another. As they get bigger this gets increasingly complex.

Complexity is inevitable, and your rate of success is directly proportional to your ability to deal with it.

### Essential difficulties
Software is currently not being developed with a mindset of tackling software engineering issues like “conformity, changeability, flexibility, invisibility and complexity”,(Brooks, 1995).

In the past, software has depended on hardware to run smoothly without malfunctioning but nowadays hardware technology is advancing rapidly by the day and becoming cheaper by the minute. However it is the opposite for software engineering, it is becoming more difficult to keep up with the advancement of hardware technology to the extent that software engineers do not bother to build software that can match up the capabilities of the current hardware capabilities.

### Complexity
The software engineering field in itself is growing, young minds are coming up with more complex programming languages to solve real life issues where applicable. Each programming language has its own specific purpose in a piece of software resulting in more complicated functions. This means a single software project can have more than five different programming languages performing different tasks which further contribute to the complexity of the functions and the software itself.

Although complex software tend to perform complex tasks, this however makes it difficult for the software to be integrated into another piece of software or advanced in some way without having to re-write majority of software functions which would in-turn cause more errors, increase costs of software maintenance that need to be dealt with in the future.

### Conformity
Every software piece ever written has to run somewhere, it has to fit-in somewhere where there have been other software systems running long before the new software was built. Software often has to be interfaced with older systems built before the current software, this makes it rather difficult for software to perform they way it was built to perform because sometimes it does not fit-in with older systems.

### Changeability
As to everything in the world, software also has a lifetime. There comes a point in a software's life-cycle where the functions and capabilities of a software need to change or improve. People are becoming wiser as the years go by, meaning people would start recognising the incapabilities of everything out there including software since our jobs and lives merely depend on it. This means a piece of software or software functions are dependent on the technological advancement of its surroundings.

### Invisibility
Unlike any other object, software can not be viewed from a bird's eye view like any object drawn in a 3D CAD(Computer Aided Diagram) system. This inability contributes to the limitations of software engineering. Software engineers tend to just build a piece of software without having a clear idea of how the final product would look or perform since there is no way to visualise it before development, which is why there is a need for a prototype to lay out the major functions of the software that seem impossible to complete.

### Solved accidental difficulties
#### High-level languages
High-level programming languages have made it easier for people to learn programming and write the famous “Hello World!” without much struggle. High-level languages are more concerned with what a user sees on the front-end of a software and how each function accomplishes a certain task rather than focusing on which register stores a particular process running in a software as lower-level languages do. High-level languages are close to plain English, this factor has contributed to the rapid growth of programmers around the world, therefore solving some of the issues in the software engineering field.

#### Time – sharing
As more people learn how to program, they start sharing insights and start to use a variety of communication medium to put their work out there for anyone to access and get solutions for problems they have been experiencing in the past.

### Hopes for the silver
#### Ada language
(Brooks, 1995) argues that Ada programming language and high-level languages are promising to tackle some of the issues experienced in software engineering, Ada was specifically designed for system functions where overall system efficiency and reliability is vital.

#### Object - oriented programming (OOP)
Object – oriented programming is one of the advancements in programming that has made it easier for programmers to define variables or objects in this matter. Each object would be defined on the basis of what data structures would be stored in it to serve a purpose in the program or software. Examples of widely used object – oriented programming languages would be C++ and Java.

#### Artificial Intelligence (AI)
(Brooks, 1995) argues that Artificial Intelligence is not what people are expecting it to be, it is merely just computer hardware and software processes which choose the best solution in a given problem likely to be chosen by humans.

### Expert Systems
Every software system should be designed and built in such a manner that it would be able to test and diagnose itself when it malfunctions, However this would not be an easy task to implement. Building an expert system would require very knowledgeable programmers which could build a general system to solve multiple complex tasks.

#### Automatic programming
It is essential to have software systems that are able to program themselves, and write program solutions of problem from a problem statement automatically.

#### Graphical programming
According to (Brooks, 1995)⁠, presentation of software functions in a graphical manner does not contribute to the simplicity of having an overview of a system since diagrams like flow charts tend to be bigger than a normal screen size of a computer. Furthermore, software functions are often more complex than they seem on a flow chart.

#### Program verification
Program verification is where most programmers spend time and it is one of the most important steps in a software life-cycle. Verifying a program before the testing phase can eliminate a lot of anomalies, it could even reduce the time spent on testing the actual software because each requirement would be verified before being implemented.

#### Environments and tools
Given the amount of tools available in this modern day to write software, there is no excuse as to why software engineers keep producing unreliable and unmaintainable software. Each programmer can program on any environment they feel comfortable, there are no limitations.

### Promising attacks on conceptual essence
As the large number of software engineers increases daily, there is more competition, more software available for anyone to utilise freely, this benefit means that whatever software one is trying to build may already be out there somewhere.

People are always trying to get things done as quick as possible, even though software engineers are to write their own software, more often it makes sense to purchase what is available out there rather than building something that has already been built.

Part of every software development model is defining the requirements, this part of a software life-cycle outlines all the necessary functions or task which the software should complete, this is where the complexity of a software project is weighed. Among software engineers, it is a known fact that “customers never know what they want”.

### How did software get better and faster in the past?
By attacking the accidental complexity. We picked the low-hanging fruit and made huge progress through the following:

#### High-level languages
The most powerful stroke for software productivity, reliability, and simplicity has been the progressive use of high-level languages for programming. Most observers credit that development with at least a factor of five in productivity, and with concomitant gains in reliability, simplicity, and comprehensibility.
#### Time-sharing
(note that the paper was written in 1987 when development resources typically had to be shared). Most observers credit time-sharing with a major improvement in the productivity of programmers and in the quality of their product, although not so large as that brought by high-level languages. Time-sharing preserves immediacy and enables us to maintain an overview of complexity. The slow turnaround of batch programming means that we inevitably forget the minutiae, if not the very thrust, of what we were thinking when we stopped programming and called for compilation and execution.
#### Unified programming environments
Unix and Interlisp, the first integrated programming environments to come into widespread use, are perceived to have improved productivity by integral factors. Why? They attack the accidental difficulties of using programs together, by providing integrated libraries, unified file formats, and piles and filters. As a result, conceptual structures that in principle could always call, feed, and use one another can indeed easily do so in practice.

### How do we make software better today?
The low-hanging fruit has been picked, what do we attack next? Brooks provides some suggestions, many of which are still relevant 34 years later.

#### Buy, don’t build.
The most radical possible solution for constructing software is not to construct it at all. Every day this becomes easier, as more and more vendors offer more and better software products for a dizzying variety of applications.

Brooks believes that the development of the mass market for software is the most profound long-run trend in software engineering. The cost of software has always been development cost, not replication cost. Sharing that cost among even a few users radically cuts the per-user cost. Another way of looking at it is that the use of n copies of a software system effectively multiplies the productivity of its developers by n.

Brooks had elsewhere proposed a marketplace for individual modules. Any such product is cheaper to buy than to build afresh. Even at a cost of $100,000, a purchased piece of software is costing only about as much as one programmer-year. And delivery is immediate, at least for products that really exist, products whose developer can refer the prospect to a happy user. Such products tend to be much better documented and somewhat better maintained than homegrown software.

You can think of this from the perspective of the buyer or the builder. Most times, it’ll make sense to buy the software. Every now and then, you’ll realise that you’re in the perfect position to build something that doesn’t exist yet, or exists, but isn’t very good. This is a chance to capitalise because if you build it well, there will be buyers.

#### Equip people with technology.
“I believe the single most powerful software productivity strategy for many organisations today is to equip the computer-naïve intellectual workers on the firing line with personal computers and good generalised writing, drawing, file and spreadsheet programs, and turn them loose. The same strategy, with simple programming capabilities, will also work for hundreds of laboratory scientists.”

While the programs might have changed, the essence of what we’re doing when we build software for people hasn’t. Building and delivering software is about giving smart people tools to make ultra-smart decisions. Equip people doing good work to go out and do great work. That’s the beauty of software, it’s an easily replicable force multiplier for people’s efforts, and it provides more leverage than almost anything else.

#### Get better at understanding what to build.
The hardest part of building software is deciding what to build.

Establishing the detailed technical requirements, including all the interfaces to people, to machines, and to other software systems, is difficult. No other part of the work so cripples the resulting system if done wrong. No other part is more difficult to rectify later.

The best developers are able to identify and understand the problem to an extent that they can build useful and delightful solutions for customers. This is why it’s so important for developers to not just be focused on the nitty-gritty implementation details, but to be product-minded about the solutions they build.


## Quest 19: 


## Quest 20: 

