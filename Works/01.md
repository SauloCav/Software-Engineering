# Quest 18: 
### Introduction
“No Silver Bullet — Essence and Accident in Software Engineering” is a widely discussed paper on software engineering written by Turing Award winner Fred Brooks in 1987. This is a summary of the key ideas.

Software engineering has its limits. No piece of software that has been build in the past is error-free or completely reliable. There is a need in the software engineering field for software development methods which would produce simple and reliable software.

uch of the progress in software engineering productivity that past generations experienced can be attributed to removing the accidental complexity that arose over time. By making hardware more efficient and accessible, and programming languages more approachable, we solved the easy problems and created an environment for more efficient development.

We’re now at a point where the low-hanging fruit has been picked, and if we want to continue building software better and faster, we need to figure out how to solve the challenges that are inherent in software development. This paper outlines how we might approach that.

### Paper Summary
The crux of the paper is that there’s no silver bullet; no one solution that is going to make software development easier, better and cheaper, all in one quick swoop.

“Skepticism is not pessimism. Although we see no startling breakthroughs, and indeed, believe such to be inconsistent with the nature of software, many encouraging innovations are underway. A disciplined, consistent effort to develop, propagate, and exploit them should indeed yield an order-of-magnitude improvement. There is no royal road, but there is a road.”

Software gets better not through magical solutions, but with great effort. Care and discipline towards the cleanliness of our code is essential to building better software. Building software to solve a problem isn’t difficult, identifying and understanding the problem is the difficult part. You cannot engineer well if you don’t understand the problem you’re solving. As Brooks says:

“I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the lab or of representing it and testing the fidelity of the representation. We still make syntax errors, to be sure; but they are fuzz compared to the conceptual errors in most systems.”

Software becomes an awful lot harder when it needs to be scaled because scaling isn’t a linear process. Scaling introduces exponential complexity because of the increasing number of interactions between elements. A scaling-up of software is not merely a repetition of the same elements in a larger size; it is necessarily an increase in the number of different elements. In most cases, the elements interact with each other in some nonlinear fashion, and the complexity of the whole increases much more than linearly.

This is pertinent to any organisation attempting to scale its engineering offerings and capabilities. There is an awful lot of complexity that comes into play as teams and products interact with one another. As they get bigger this gets increasingly complex.

Complexity is inevitable, and your rate of success is directly proportional to your ability to deal with it.

### Essential difficulties
Software is currently not being developed with a mindset of tackling software engineering issues like “conformity, changeability, flexibility, invisibility and complexity”,(Brooks, 1995).

In the past, software has depended on hardware to run smoothly without malfunctioning but nowadays hardware technology is advancing rapidly by the day and becoming cheaper by the minute. However it is the opposite for software engineering, it is becoming more difficult to keep up with the advancement of hardware technology to the extent that software engineers do not bother to build software that can match up the capabilities of the current hardware capabilities.

### Complexity
The software engineering field in itself is growing, young minds are coming up with more complex programming languages to solve real life issues where applicable. Each programming language has its own specific purpose in a piece of software resulting in more complicated functions. This means a single software project can have more than five different programming languages performing different tasks which further contribute to the complexity of the functions and the software itself.

Although complex software tend to perform complex tasks, this however makes it difficult for the software to be integrated into another piece of software or advanced in some way without having to re-write majority of software functions which would in-turn cause more errors, increase costs of software maintenance that need to be dealt with in the future.

### Conformity
Every software piece ever written has to run somewhere, it has to fit-in somewhere where there have been other software systems running long before the new software was built. Software often has to be interfaced with older systems built before the current software, this makes it rather difficult for software to perform they way it was built to perform because sometimes it does not fit-in with older systems.

### Changeability
As to everything in the world, software also has a lifetime. There comes a point in a software's life-cycle where the functions and capabilities of a software need to change or improve. People are becoming wiser as the years go by, meaning people would start recognising the incapabilities of everything out there including software since our jobs and lives merely depend on it. This means a piece of software or software functions are dependent on the technological advancement of its surroundings.

### Invisibility
Unlike any other object, software can not be viewed from a bird's eye view like any object drawn in a 3D CAD(Computer Aided Diagram) system. This inability contributes to the limitations of software engineering. Software engineers tend to just build a piece of software without having a clear idea of how the final product would look or perform since there is no way to visualise it before development, which is why there is a need for a prototype to lay out the major functions of the software that seem impossible to complete.

### Solved accidental difficulties
#### High-level languages
High-level programming languages have made it easier for people to learn programming and write the famous “Hello World!” without much struggle. High-level languages are more concerned with what a user sees on the front-end of a software and how each function accomplishes a certain task rather than focusing on which register stores a particular process running in a software as lower-level languages do. High-level languages are close to plain English, this factor has contributed to the rapid growth of programmers around the world, therefore solving some of the issues in the software engineering field.

#### Time – sharing
As more people learn how to program, they start sharing insights and start to use a variety of communication medium to put their work out there for anyone to access and get solutions for problems they have been experiencing in the past.

### Hopes for the silver
#### Ada language
(Brooks, 1995) argues that Ada programming language and high-level languages are promising to tackle some of the issues experienced in software engineering, Ada was specifically designed for system functions where overall system efficiency and reliability is vital.

#### Object - oriented programming (OOP)
Object – oriented programming is one of the advancements in programming that has made it easier for programmers to define variables or objects in this matter. Each object would be defined on the basis of what data structures would be stored in it to serve a purpose in the program or software. Examples of widely used object – oriented programming languages would be C++ and Java.

#### Artificial Intelligence (AI)
(Brooks, 1995) argues that Artificial Intelligence is not what people are expecting it to be, it is merely just computer hardware and software processes which choose the best solution in a given problem likely to be chosen by humans.

### Expert Systems
Every software system should be designed and built in such a manner that it would be able to test and diagnose itself when it malfunctions, However this would not be an easy task to implement. Building an expert system would require very knowledgeable programmers which could build a general system to solve multiple complex tasks.

#### Automatic programming
It is essential to have software systems that are able to program themselves, and write program solutions of problem from a problem statement automatically.

#### Graphical programming
According to (Brooks, 1995)⁠, presentation of software functions in a graphical manner does not contribute to the simplicity of having an overview of a system since diagrams like flow charts tend to be bigger than a normal screen size of a computer. Furthermore, software functions are often more complex than they seem on a flow chart.

#### Program verification
Program verification is where most programmers spend time and it is one of the most important steps in a software life-cycle. Verifying a program before the testing phase can eliminate a lot of anomalies, it could even reduce the time spent on testing the actual software because each requirement would be verified before being implemented.

#### Environments and tools
Given the amount of tools available in this modern day to write software, there is no excuse as to why software engineers keep producing unreliable and unmaintainable software. Each programmer can program on any environment they feel comfortable, there are no limitations.

### Promising attacks on conceptual essence
As the large number of software engineers increases daily, there is more competition, more software available for anyone to utilise freely, this benefit means that whatever software one is trying to build may already be out there somewhere.

People are always trying to get things done as quick as possible, even though software engineers are to write their own software, more often it makes sense to purchase what is available out there rather than building something that has already been built.

Part of every software development model is defining the requirements, this part of a software life-cycle outlines all the necessary functions or task which the software should complete, this is where the complexity of a software project is weighed. Among software engineers, it is a known fact that “customers never know what they want”.

### How did software get better and faster in the past?
By attacking the accidental complexity. We picked the low-hanging fruit and made huge progress through the following:

#### High-level languages
The most powerful stroke for software productivity, reliability, and simplicity has been the progressive use of high-level languages for programming. Most observers credit that development with at least a factor of five in productivity, and with concomitant gains in reliability, simplicity, and comprehensibility.
#### Time-sharing
(note that the paper was written in 1987 when development resources typically had to be shared). Most observers credit time-sharing with a major improvement in the productivity of programmers and in the quality of their product, although not so large as that brought by high-level languages. Time-sharing preserves immediacy and enables us to maintain an overview of complexity. The slow turnaround of batch programming means that we inevitably forget the minutiae, if not the very thrust, of what we were thinking when we stopped programming and called for compilation and execution.
#### Unified programming environments
Unix and Interlisp, the first integrated programming environments to come into widespread use, are perceived to have improved productivity by integral factors. Why? They attack the accidental difficulties of using programs together, by providing integrated libraries, unified file formats, and piles and filters. As a result, conceptual structures that in principle could always call, feed, and use one another can indeed easily do so in practice.

### How do we make software better today?
The low-hanging fruit has been picked, what do we attack next? Brooks provides some suggestions, many of which are still relevant 34 years later.

#### Buy, don’t build.
The most radical possible solution for constructing software is not to construct it at all. Every day this becomes easier, as more and more vendors offer more and better software products for a dizzying variety of applications.

Brooks believes that the development of the mass market for software is the most profound long-run trend in software engineering. The cost of software has always been development cost, not replication cost. Sharing that cost among even a few users radically cuts the per-user cost. Another way of looking at it is that the use of n copies of a software system effectively multiplies the productivity of its developers by n.

Brooks had elsewhere proposed a marketplace for individual modules. Any such product is cheaper to buy than to build afresh. Even at a cost of $100,000, a purchased piece of software is costing only about as much as one programmer-year. And delivery is immediate, at least for products that really exist, products whose developer can refer the prospect to a happy user. Such products tend to be much better documented and somewhat better maintained than homegrown software.

You can think of this from the perspective of the buyer or the builder. Most times, it’ll make sense to buy the software. Every now and then, you’ll realise that you’re in the perfect position to build something that doesn’t exist yet, or exists, but isn’t very good. This is a chance to capitalise because if you build it well, there will be buyers.

#### Equip people with technology.
“I believe the single most powerful software productivity strategy for many organisations today is to equip the computer-naïve intellectual workers on the firing line with personal computers and good generalised writing, drawing, file and spreadsheet programs, and turn them loose. The same strategy, with simple programming capabilities, will also work for hundreds of laboratory scientists.”

While the programs might have changed, the essence of what we’re doing when we build software for people hasn’t. Building and delivering software is about giving smart people tools to make ultra-smart decisions. Equip people doing good work to go out and do great work. That’s the beauty of software, it’s an easily replicable force multiplier for people’s efforts, and it provides more leverage than almost anything else.

#### Get better at understanding what to build.
The hardest part of building software is deciding what to build.

Establishing the detailed technical requirements, including all the interfaces to people, to machines, and to other software systems, is difficult. No other part of the work so cripples the resulting system if done wrong. No other part is more difficult to rectify later.

The best developers are able to identify and understand the problem to an extent that they can build useful and delightful solutions for customers. This is why it’s so important for developers to not just be focused on the nitty-gritty implementation details, but to be product-minded about the solutions they build.


# Quest 19: 

O uso do homem-mês como unidade de esforço usada para estimativas e cronogramas é sem dúvidas a maior e mais perigosa falácia da engenharia de software. Isso implica que homens e meses são intercambiáveis, o que não é verdade no mundo da programação. Essa lógica é válida apenas em contextos que são completamente divisíveis e não dependentes, como por exemplo, debulhar 1 tonelada de milho.

Quando uma tarefa não pode ser dividida por limitações sequenciais, como é o caso do software, a adição de mais força de trabalho não implica na redução do tempo de entrega daquela tarefa.

"Uma mulher grávida leva nove meses para parir um filho, porém nove mulheres não parem um filho em um mês."

Isso deveria ser básico para qualquer pessoa que gerencia uma equipe envolvida com software. Mas infelizmente não é.

O livro detalha como adicionar pessoas a um projeto atrasado é a causa dos atrasos subsequentes. Quantas pessoas o gestor deve alocar para uma atividade, a fim de otimizar o seu tempo de entrega, é definitivamente uma das atividades mais difíceis da engenharia de software. Com poucos homens, irá demorar mais, porém com muitos homens pode demorar ainda mais. Encontrar esse meio termo é o nosso desafio.

Brooks questiona: Como um projeto pode atrasar um ano? Resposta mais clara é impossível: Atrasando um dia de cada vez.

A maioria dos programadores são otimistas, porém a premissa de que “tudo irá bem” e que “cada tarefa tomará apenas o tempo que deve tomar” é completamente falsa. Na programação, tudo é interdependente. Se der algo errado numa tarefa, a tarefa seguinte, que depende da primeira, também irá sair do planejado. E assim o projeto vai atrasando dia após dia, de maneira cumulativa.



IF YOU'VE EVER WORKED ON A SOFTWARE DEVELOPMENT PROJECT UNDER A TIME CRUNCH, THEN YOU MAY HAVE HEARD THE PHRASE "MYTHICAL MAN MONTH."
This phrase will often get uttered by a well-read team member when presented with a business stakeholder who wants to throw more bodies at the project to make it go faster. As often as the concept comes up, it never really lives beyond my under-the-breath mutterings. I tend not to share it with clients. Because how do you explain the “mythical man month” to Mr. CEO In A Hurry?

Well for starters, it’s helpful to read the essay. Frederick P. Brooks warns us that in software, man hours and months are not interchangeable. You can’t add more men in order to make a project go faster. CEOs and businessey types are prone to thinking this way because it’s true in most other production settings (e.g. manufacturing or farming).

Adding more labor to go faster doesn't work in software for two reasons:

1. Programming tasks are not partitionable.
“Men and months are interchangeable commodities only when a task can be partitioned among many workers with no communication among them.” Here’s a picture for graphy types:

If the tasks can’t be partitioned, they have sequential constraints. This means that increasing the team won’t bring any speed gains.

i.e. No matter how many women you add to a baby-making team, it will still take 9 months to produce that baby!

2. Programming requires communication.

There are two types of communication: training-related and task-related. The real drain is task-related intercommunication, which increases level of effort by n(n-1)/2 with each new team member.
So team-of-3 requires three times the intercommunication of team-of-2.
And team-of-4 requires six times the intercommunication of team-of-2.

Any gains in task completion are saddled with huge increases in project communication overhead. And so you are no better off deadline-wise.

Wonder if I ought to carry these graphs around — ready to whip out during any client meeting. Or maybe I should practice drawing them on the whiteboard.

It’s hard to believe this book was written in 1975. So much of what Brooks describes are concepts and practices that didn't even have a name yet.

Some passages read like software engineering history (sharing machine time and employing documentation secretaries?). And others like The Mythical Man Month read as if they were written yesterday.

Well... except for the “Man” part.



- More software projects have gone awry for lack of calendar time than for all other causes combined.
- Why? a) Estimation techniques are under-developed, especially in assuming all will go well. b) People and time are not interchangeable. c) Software managers are not stubborn in pushing back against management. d) Schedule progress is poorly monitored, and techniques proven in other fields are not adopted in software. e) When a project is delayed, more people are added, which is like dousing a fire with petrol.
- Let’s look at these one by one. We tend to be optimistic about our ideas, but their incompleteness and inconsistencies becomes clear only during implementation.
- More the tasks in a project, more the chance that one will slip, delaying the entire project. Big projects are guaranteed to be late.
- Doubling head count halves time only if there’s no overhead. This overhead comes in two varieties: a) Training in technology, goals, and how the team is being run. This can’t be partitioned; it increases linearly with headcount b) Communication, which is quadratic, or worse considering multi-person meetings.
- Because of all this, adding people causes the schedule to shorten at a lower rate than the ideal 1/N, and actually lengthen beyond a point.
- To schedule a software task, allocate time to a) Planning b) Coding c) Debugging
- The parts of a task that are easy to estimate end up taking less time.
- Cutting testing time because of schedule pressure results in unplanned delays instead of planned delays. This is worse.
- If an omelette is promised in two minutes but doesn’t arrive, turning up the heat will produce an omelette half burned and half raw.
- Making unreasonable schedules to meet management’s desired date is more common in software than other engineering fields because we have no hard data, only hunches.
- Software engineers should share more data about productivity, bug frequency, estimating rules, and so on.
- Managers should stiffen their backbones and defend their hunches, since they’re better than wishful thinking on the part of management.
- When a project is delayed, trim the task and try to stick to the timeline.
- Adding manpower to a late project makes it later.
- You can take a given schedule and lengthen it by reducing manpower, but not the other way around.



# Quest 18 resumida: 
Nenhuma solução que tornará o desenvolvimento de software mais fácil, melhor e mais barato, tudo de uma só vez!

Muitas inovações encorajadoras estão em andamento. Um esforço disciplinado e consistente para desenvolvê-los, propagá-los e explorá-los deve, de fato, produzir uma melhoria de ordem de magnitude. Porém não existe bala de prata pois sempre haverão dificuldades envolvidas no processo de desenvolvimento de software.

Segundo Brooks, existem dois tipos de dificuldades em desenvolvimento de software: dificuldades essenciais e dificuldades acidentais. As essenciais são da natureza da área e dificilmente serão superadas por qualquer nova tecnologia ou método que se invente. Já as dificuldades acidentais estão associadas a problemas tecnológicos, que os Engenheiros de Software podem resolver, se devidamente treinados e caso tenham acesso às devidas tecnologias e recursos.

## Dificuldades essenciais:
### Complexidade
### Conformidade
### Modificabilidade
### Invisibilidade

## Dificuldades acidentais resolvidas
### Linguagens de alto nível
As linguagens de alto nível estão próximas do inglês simples, esse fator contribuiu para o rápido crescimento de programadores em todo o mundo, resolvendo assim alguns dos problemas no campo da engenharia de software.

### Compartilhamento de tempo
À medida que mais pessoas aprendem a programar, elas começam a compartilhar ideias e a usar uma variedade de meios de comunicação para divulgar seu trabalho para que todos possam acessar e obter soluções para problemas que enfrentaram no passado.

### Ambientes de programação unificados
Unix e Interlisp, os primeiros ambientes de programação integrados a serem amplamente utilizados. Eles atacam as dificuldades acidentais de usar programas juntos, fornecendo bibliotecas integradas, formatos de arquivo unificados e pilhas e filtros.

## Além disso, Brooks fornece algumas sugestões de como tornarmos os softwares melhores nos dias atuais:
### Compre, não construa.
A solução mais radical possível para a construção de software é não construí-lo. A cada dia isso se torna mais fácil, à medida que mais e mais fornecedores oferecem mais e melhores produtos de software para uma variedade estonteante de aplicativos.

### Equipar as pessoas com tecnologia.
Embora os programas possam ter mudado, a essência do que estamos fazendo quando criamos software para as pessoas não mudou. Construir e entregar software é dar ferramentas para pessoas inteligentes tomarem decisões ultra-inteligentes. Equipe as pessoas que fazem um bom trabalho para sair e fazer um ótimo trabalho.

### Entenda melhor o que construir.
A parte mais difícil da construção de software é decidir o que construir.

O mais impressionante do artigo de brooks é o quanto ele não envelheceu. Os conceitos apresentados e as sugestões sugeridas seguem se aplicando até os dias atuais. Mesmo o chatGPT com todo o seu poderio e popularidade não será uma bala de prata. Mesmo linguagens cada vez mais avançadas não serão ua bala de prata. "There's no silver bullet".

# Quest 19 resumida: 
Em software, horas-homem e meses não são intercambiáveis. Você não pode adicionar mais homens para fazer um projeto ir mais rápido. CEOs e tipos de negócios tendem a pensar dessa maneira porque é verdade na maioria dos outros ambientes de produção (por exemplo, manufatura ou agricultura).

Brooks questiona: "Como um projeto pode atrasar um ano? Atrasando um dia de cada vez!"

A maioria dos programadores são otimistas, porém a premissa de que “tudo irá bem” e que “cada tarefa tomará apenas o tempo que deve tomar” é completamente falsa. Na programação, tudo é interdependente. Se der algo errado numa tarefa, a tarefa seguinte, que depende da primeira, também irá sair do planejado. E assim o projeto vai atrasando dia após dia, de maneira cumulativa. Mais projetos de software deram errado por falta de tempo no calendário do que por todas as outras causas combinadas.

Adicionar mais trabalho para ir mais rápido não funciona no software pelos seguintes motivos:

### 1. As tarefas de programação não são particionáveis.
Homens e meses são mercadorias intercambiáveis apenas quando uma tarefa pode ser dividida entre muitos trabalhadores sem comunicação entre eles.
Se as tarefas não puderem ser particionadas, elas terão restrições sequenciais. Isso significa que aumentar a equipe não trará nenhum ganho de velocidade.
Quando uma tarefa não pode ser dividida por limitações sequenciais, como é o caso do software, a adição de mais força de trabalho não implica na redução do tempo de entrega daquela tarefa.
"Uma mulher grávida leva nove meses para parir um filho, porém nove mulheres não parem um filho em um mês."

### 2. As técnicas de estimativa estão subdesenvolvidas, especialmente ao assumir que tudo correrá bem.
Fazer cronogramas irracionais para atender a data desejada pela administração é mais comum em software do que em outras áreas de engenharia porque não temos dados concretos, apenas palpites. E o pior tipo de palpite possível é o otimista.

### 3. O andamento do cronograma é mal monitorado e técnicas comprovadas em outras áreas não são adotadas no software.
Os engenheiros de software devem compartilhar mais dados sobre produtividade, frequência de bugs, regras de estimativa e assim por diante. Além disso, de nada adianta usar métricas de produtividade de outras áreas como indústrias na produção de software.

### 4. Quando um projeto é adiado, mais pessoas são adicionadas
Você pode pegar um determinado horário e alongá-lo reduzindo a mão de obra, mas não o contrário. Quando um projeto está atrasado, reduza a tarefa e tente seguir o cronograma. Adicionar mão-de-obra a um projeto atrasado torna-o mais atrasado.

### 5. Programação requer comunicação.
Existem dois tipos de comunicação: relacionada ao treinamento e relacionada à tarefa. O verdadeiro dreno é a intercomunicação relacionada à tarefa, que aumenta o nível de esforço em n(n-1)/2 com cada novo membro da equipe.
Portanto, o time de 3 requer três vezes a intercomunicação do time de 2. E o time de 4 requer seis vezes a intercomunicação do time de 2.
Quaisquer ganhos na conclusão da tarefa são sobrecarregados com grandes aumentos na sobrecarga de comunicação do projeto. E, portanto, você não está melhor em termos de prazo.

