# Quest 10



# Quest 11
Débito técnico, code smell e refactoring são conceitos interligados, relacionados à qualidade do código em desenvolvimento de software. Vamos entender a diferença entre eles e fornecer dois exemplos para cada:

## Débito técnico:
Débito técnico refere-se aos compromissos de curto prazo feitos durante o desenvolvimento de software, com o objetivo de entregar um produto mais rapidamente, mas que resultam em problemas e custos futuros. É como um empréstimo que precisa ser pago posteriormente. Exemplos de débito técnico incluem:

1. Uso de código duplicado: Em vez de abstrair funcionalidades comuns em uma função reutilizável, um desenvolvedor pode copiar e colar o código em várias partes do programa. Embora isso economize tempo inicialmente, torna a manutenção mais difícil e aumenta a probabilidade de erros.

2. Falta de testes abrangentes: Quando os prazos são apertados, os testes podem ser negligenciados ou feitos de forma insuficiente. Isso pode resultar em problemas não detectados, levando a bugs e instabilidade no software.

##  Code smell (cheiro de código):
Code smells são características do código que indicam possíveis problemas de design e manutenção. Eles são sinais de que algo pode estar errado no código. Exemplos de code smells incluem:

1. Métodos muito longos: Um método que se estende por muitas linhas pode ser difícil de entender e manter. Isso indica uma possível falta de decomposição adequada da lógica em unidades menores e mais coesas.

2. Nome de variáveis confusos: Utilizar nomes pouco descritivos para variáveis dificulta a compreensão do propósito e do significado das mesmas. Isso pode levar a erros de lógica e aumentar a complexidade cognitiva para outros desenvolvedores.

##  Refactoring:
Refactoring é o processo de reestruturar o código existente sem alterar seu comportamento externo, com o objetivo de melhorar sua qualidade e legibilidade. O refactoring ajuda a eliminar code smells e reduzir o débito técnico. Exemplos de refactoring incluem:

1. Extração de método: Se um trecho de código for repetido em várias partes do programa, é possível extrair esse trecho em um método separado para evitar duplicação. Isso torna o código mais limpo, mais fácil de entender e mais fácil de manter.

2. Simplificação de condicionais complexas: Quando as estruturas condicionais se tornam muito complexas, é possível aplicar refactoring para simplificar e tornar a lógica mais legível. Isso pode envolver a extração de condições em variáveis booleanas com nomes descritivos ou o uso de técnicas como "guard clauses" para reduzir a profundidade dos aninhamentos.

Esses exemplos ilustram a diferença entre débito técnico (um compromisso de curto prazo que pode resultar em problemas futuros), code smells (características do código que indicam problemas potenciais) e refactoring (o processo de melhorar a qualidade do código através de modificações controladas). O refactoring é uma prática contínua que visa eliminar code smells e reduzir o débito técnico ao longo do tempo.


# Quest 12



# Quest 13



# Quest 14
## Abordagem Monorepo:
Na abordagem Monorepo, todo o código-fonte de um projeto ou organização é mantido em um único repositório. Aqui estão algumas vantagens e desvantagens dessa abordagem:

### Vantagens do Monorepo:
1. Facilidade de compartilhamento de código: Com todo o código em um único repositório, é mais fácil compartilhar código entre diferentes partes do projeto ou equipe. Isso promove a reutilização e a colaboração, evitando a duplicação desnecessária de código.

2. Coerência e consistência do código: Ter todo o código em um único repositório permite manter um estilo de código consistente e aplicar políticas e padrões de desenvolvimento de maneira mais eficiente. Isso facilita a manutenção e a compreensão do código.

3. Simplificação da integração contínua e entrega contínua: Com um único repositório, a integração contínua (CI) e a entrega contínua (CD) são mais fáceis de serem implementadas, pois o código é construído e testado em um contexto unificado. Isso facilita a implantação e a entrega de alterações.

### Desvantagens do Monorepo:
1. Complexidade de gerenciamento: À medida que o tamanho do projeto cresce, o gerenciamento do Monorepo pode se tornar mais complexo. Lidas com grandes volumes de código, dependências e ramificações simultâneas podem exigir ferramentas e estratégias adicionais para garantir a eficiência e a segurança do desenvolvimento.

2. Overhead de clonagem e build: Trabalhar com um Monorepo significa que todas as partes do código precisam ser clonadas e compiladas juntas, mesmo quando alterações são feitas em apenas uma parte do projeto. Isso pode resultar em tempos de clonagem e compilação mais longos, especialmente em projetos grandes.

## Abordagem Multirepo:
Na abordagem Multirepo, cada componente ou serviço é mantido em um repositório separado. Aqui estão algumas vantagens e desvantagens dessa abordagem:

### Vantagens do Multirepo:
1. Desacoplamento e independência: Cada repositório em uma abordagem Multirepo é independente, o que facilita a separação de preocupações e permite que as equipes trabalhem de forma mais autônoma. Isso pode ser benéfico para projetos grandes com várias equipes trabalhando em diferentes partes do sistema.

2. Controle granular de versões e permissões: Com repositórios separados, é mais fácil controlar e gerenciar versões de componentes individuais. Além disso, as permissões de acesso podem ser configuradas com mais precisão, concedendo acesso específico a repositórios relevantes para cada equipe ou membro.

### Desvantagens do Multirepo:
1. Duplicação de código e dependências: Em uma abordagem Multirepo, é mais fácil ocorrer duplicação de código, uma vez que os componentes não estão necessariamente compartilhando um repositório centralizado. Além disso, o gerenciamento de dependências entre repositórios separados pode se tornar mais complexo.

2. Coerência e sincronização: Manter a coerência e a sincronização entre diferentes repositórios pode exigir esforço


# Quest 15



# Quest 16



# Quest 17



# Quest 18


